\subsection{A solução}

  Em função das limitações de tamanho e tempo, observou-se uma oportunidade para utilização de abordagem baseada em metodologias ágeis. No entanto, não é objetivo discorrer sobre o andamento de um projeto de software em sua completude mas, focar em algumas técnicas de desenvolvimento utilizadas. De tal forma, contamos com uma certa indulgência do leitor no que se refere a omissões descritivas dos caminhos gerenciais tomados.

  Usando \emph{histórias de usuário} como método de requisitos observamos a existência de muitas delas, de tal forma que se faz necessário organizar as mesmas dentro de um fluxo de capacidade mínimo \footnote{\citeonline{Patton2014} apresentam uma técnica, \emph{Mapeamento de Histórias de Usuário}, bastante útil para identificar fluxos e definir sua importância, em particular para o contexto em que não existe um proprietário de projeto - PO - capaz de priorizar as histórias que mais lhe agregam valor.} para completar as intenções firmadas no escopo. Daí se chega à \figref{mapeamento-historias-usuario}, onde se observa que 7 histórias são essenciais: \emph{criar conta; entrar; sair; chamar partida; atender chamado para partida; colocar peça em jogo; e, movimentar peça}. Isso define a abrangência do lançamento\footnote{Do inglês, \textbf{release}}. Sentimos, por experiência, que a última tem tendência para um \emph{épico}\footnote{\cite[pág. 6]{Cohn2004}}, por si só, mas,  para evitar a \emph{paralisia de análise}\footnote{\cite[pág. 71]{Pugh2011}}, vamos procrastinar a decisão de dividí-la\footnote{\cite[pág. 24]{Cohn2004}}, até que lidemos com ela especificamente. Esse sentimento também nos ajuda a escolher, para a primeira interação, a história de usuário \emph{Criar conta}.

  \imagem
    {width=16cm}
    {Mapeamento de histórias de usuário}
    {mapeamento-historias-de-usuario.miro}
    {mapeamento-historias-usuario}
    {Próprio autor\footnotemark}
  \footnotetext{Utilizando o serviço https://miro.com/}

  Factualmente, existem duas escolas de TDD: \emph{Chicago} - encontrada, ainda, como inside-out (de dentro para fora), classicista, bottom-up (de baixo para cima) - e \emph{Londres} - também conhecida como outside-in (de fora para dentro), mockista, top-down (de cima para baixo). Segundo \citeonline[págs. 488-492] {BryantPerez2019}, a tecnologia utilizada, mecanismos de construção, habilidades e preferências pessoais irão determinar que abordagem escolher. Mas também cita algumas características que ajudam nesta: possui bem delineadas as regras do negócio ou terá que traduzir o processo dos interessados em regras que possam ser automatizadas; existem restrições de plataforma (deve ser uma aplicação web, deve usar um determinado servidor de banco de dados, etc).

  Sendo assim, optamos pela abordagem londrina, que tem como principais representantes \citeonline{FreemanPryce2009}. A primeira observação é sobre o ciclo que, nessa perspectiva, possui dois níveis de execução (\figref{ciclo-atdd}). Graças a isso, é esperado que a etapa mais externa permanesça por mais tempo em estado de falha.

  \imagem
    {scale=0.5}
    {Duplo ciclo da escola londrina de tdd}
    {ciclo-atdd.png}
    {ciclo-atdd}
    {Próprio autor\footnotemark}
  \footnotetext{Baseado na imagem encontrada em \citeonline[pág. 40]
  {FreemanPryce2009}}

  Também somos forçados a definir um esboço estrutural dos componentes (\figref{esboco-estrutural}) de auto nível sobre o qual repousaremos a solução (inicialmente - pois ela pode, ou não, vir a ser modificado durante o transcorrer do projeto).

  \imagem
    {scale=0.5}
    {Esboço estrutural dos componentes da solução}
    {esboco-estrutural.png}
    {esboco-estrutural}
    {Próprio autor}

  Para levantar as histórias, \citeonline{Cohn2004} sugere o seguinte método: identificar os papéis; utilizá-los para construir narrativas no formato \emph{Connextra}\footnote{\citeonline{Connextra2001} propõs um modelo baseado na tríade \emph{papel-funcionalidade-benefício} ou, mais explicitamente, \narrativa{papel}{uma funcionalidade}{conseguir um benefício}}; levantar os critérios de aceite de cada história.

  Com a história \emph{Criar conta} chegamos a seguinte narrativa: \narrativa{visitante}{criar uma conta}{entrar e jogar uma partida}.

  Também foram levantados os seguintes critérios de aceite: deve ser informado um email válido; deve ser informada uma senha de tamanho mínimo 8 (oito) e tamanho máximo 20 (vinte) caracteres; não deve ser possível criar uma conta para um email que já vinculado a uma outra conta; deve constar um registro na base de dados.

  Já há elementos para elencarmos os cenários a serem trabalhados (\figref{criar-conta.cenarios}). Também é possível detalhar os passos de cada um deles usando o método sugerido por \citeonline{Nicieja2018} para derivação a partir dos critérios de aceite. O formato, \emph{Gherkin}, se baseia no artigo de \citeonline{North2006}.

  \imagem
    {scale=0.6}
    {\textbf{Cenários} elencados para a \textbf{história} \emph{Criar conta}}
    {criar-conta.feature.png}
    {criar-conta.cenarios}
    {Próprio autor}

  Essa estrutura se alicerça na seguinte ideia: o passo identificado por \textbf{Dado} define o \emph{contexto} - pré-condição - onde a \emph{ação} (\textbf{Quando}) deve acontecer para que o \emph{resultado esperado} - pós-condição - (\textbf{Então}) seja observado.

  Há de salientar que os passos dos cenários descritos são, suficientemente, abstratos para permitir que os não-técnicos o leiam (ou, ainda, desejavelmente, os escrevam) mas não tanto que inviabilizar a sua automatização. Construímos o que \citeonline[pág. 24]{Evans2003} chama de \emph{linguagem ubíqua}. Dentre outros benefícios se pode citar a não fragilidade\footnote{\cite[pág. 93]{RoseWynneHellesoy2015} Do inglês, \textbf{brittle features}} desses artefatos, tornando-os resilientes às alterações de implementação, enquanto o comportamento esperado se mantiver intacto. Essa característica é essencial para subsidiar a \emph{refatoração}\footnote{\cite{Fowler1999}} e, por sua vez, é condição para o alvo mirado, a \emph{arquitetura limpa}.

  Retomando o esboço estrutural, o enriquecemos com os componentes que substituirão a figura humana no processo, dando vida própria a documentação\footnote{\citeonline[pág. 29]{Adzic2011} Live documentation}, donde se chega a \figref{esboco-estrutural-enriquecido}.

  \imagem
    {width=12cm}
    {Esboço estrutural enriquecido com os componentes que permitem a automatização}
    {esboco-estrutural-enriquecido.png}
    {esboco-estrutural-enriquecido}
    {Própio autor}

  Existem muitos mitos em torno das metodologias ágeis, e uma delas é a não existência de modelagem. Essa falsa crença se dá, muitas vezes, por uma noção equivocada de que documentação e modelos são equivalentes. \citeonline{Ambler2002} desconstrói esses mitos e mostra que essa atividade é, além de possível, basilar para um bom projeto de software. Isso nos permite, por exemplo, rabiscar uma solução para o cenário descrito\footnote{\citeonline[pág. 57]{Ruby2011} usa o mesmo processo para construir a solução apresentada no livro}, como pode ser observado na \figref{modelo-solucao.criar-conta-deve-ser-bem-sucedido.jpeg}.

  \imagem
    {width=12cm}
    {Modelo visual para solucionar o \textbf{cenário} \emph{deve ser bem sucedido} da \textbf{história} \emph{Criar conta}}
    {modelo-solucao.criar-conta-deve-ser-bem-sucedido.jpeg}
    {modelo-solucao.criar-conta-deve-ser-bem-sucedido.jpeg}
    {Própio autor}

  Esse ponto é auxiliado pelo que \citeonline[págs. 142 e 226]{Abelson1996} chama de \emph{wishful thinking}\footnote{Pensamento positivo, em tradução livre.} - mais precisamente o que \citeonline[pág. 45]{Astels2003} denomina \emph{programar por intenção} - para implementar os passos do cenário apresentados como se a funcionalidade pretendida já existisse. O objetivo é ser o mais claro possível sobre o que se almeja com aquela especificação, o resultado pode ser visto na \figref{criar-conta.deve-ser-bem-sucedido.passos}.

  \imagem
    {width=12cm}
    {Implementação dos passos do \textbf{cenário} \emph{deve ser bem sucedido} da \textbf{história} \emph{Criar conta}}
    {implementacao.cenario.js.png}
    {criar-conta.deve-ser-bem-sucedido.passos}
    {Própio autor}

  Essa etapa pode divergir bastante entre os diversos autores que tratam do tema, no que tange os conceitos de \emph{baby steps}\footnote{\cite[pág. 1]{Aniche2011}}, \emph{iniciar pelas verificações}, \emph{usar somente uma asserção por cenário}, \emph{não usar asserções fora da fase de verificação}. No fim, prevalecem, \emph{a familiaridade com as tecnologias empregadas}, \emph{a experiência no processo de desenvolvimento guiado por testes}, \emph{a simplicidade}\footnote{\cite[pág. xii]{Beck2003}}, mas, principalmente, \emph{o bom senso}.

  Como dito antes, o modelo londrino supõe a ciência prévia de determinados componentes da solução, de tal forma que o código da especificação funciona como uma tela de proteção no picadero de um circo funciona para os artistas do trapézio. Esse, talvez, seja o motivo de, algumas vezes, se tomar atalhos como o não uso de testes unitários em cenários em que, pela experiência, não apresentam grandes desafios. Ou seja, o desenvolvedor sabe o que quer fazer, mas para evitar horas procurando uma vírgula mal colocada, ele se utiliza da espeficifação automatizada para validar o caminho que ele está tomando. Essa mesma, lhe garantirá a não regressão de um caso, no momento em que um caminho mais elegante, internamente falando, for imaginado.

  Para este cenário, em particular, vemos, claramente, 2 componentes fundamentais: entrada de dados - ui (interface de usuário, mas poderia ser uma interface de código, se nossa solução fosse destinada a outros sistemas ao invés de humanos); e, saída de dados - db (que poderia envolver outros atores, como, por exemplo, um servidor de envio de mensagens eletrônicas externo, caso fossemos exigir ativação da conta por algum link encaminhado por email).

  Esperamos que, ao final da execução deste caso de teste, durante a verificação dos \emph{resultados esperados}, tenhamos um registro que nos comprove que a entrada de dados foi devidamente persistida. Isso deve ocorrer em contraposição ao \emph{contexto} do teste, em que o dito registro não deve existir. Assim nosso primeiro passo na direção da completude do cenário é a criação da consulta que faz a verificação da ausência do registro na base de dados (\figref{criar-conta-deve-ser-bem-sucedido-passo.dado}).

  \begin{figure}[h]
    \centering
    \efbox[rightline=false,topline=false,leftline=false,bottomline=false]{
      \makebox[\textwidth]{
        \begin{subfigure}[t]{0.5\textwidth}
          \centering
          \caption{Banco de dados}
          \includegraphics[width=\textwidth]{db.js.png}
          \label{fig:criar-conta-deve-ser-bem-sucedido-passo.dado}
          \label{fig:criar-conta-deve-ser-bem-sucedido-passo.entao}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.5\textwidth}
          \centering
          \caption{Interface de usuário}
          \includegraphics[width=\textwidth]{ui.js.png}
          \label{fig:criar-conta-deve-ser-bem-sucedido-passo.quando}
        \end{subfigure}
      }
    }
    \caption{Implementação do código de suporte do cenário}
    \small{Fonte: Próprio autor}
    \label{fig:suporte-cenario}
  \end{figure}

  Para o passo que representa a ação, vemos que existem níveis de abstração, ao observar que o comando \emph{quando eu me registro}, na verdade é uma composição de 3 ações: abrir a página do formulário de registro; preencher os campos obrigatórios do mesmo (que, por si só, já é uma composição pois resume o preenchimento de muitos campos a uma única ação composta); e, finalmente, submeter essas informações pelo clique no botão \emph{registrar} (\figref{criar-conta-deve-ser-bem-sucedido-passo.quando}).

  Por fim, temos o passo de verificação, como já havíamos adiantado, reutilizamos o código de suporte da pré-condição que deve ter o efeito oposto nesse momento, bem como a da existência de uma mensagem de feedback do sucesso da ação (\figref{criar-conta-deve-ser-bem-sucedido-passo.entao}).

  Isso conclui o trabalho de construção da rede de proteção que nos permitirá implementar a funcionalidade com a confiança de que seremos apoiados pela especificação automatizada. Desse momento em diante, podemos, inclusive, escolher a plataforma que melhor nos convier (desde que atenda aos limites mínimos impostos, que nesse caso são: uma aplicação web e um banco de dados relacional suportado pela plataforma). Ou seja, a miriade de possibilidades em que essa solução pode ser implementada é enorme. Para o nosso caso, em particular, escolhemos um frontend em React e um backend em Java/Quarkus e um banco de dados PostgreSQL.

  Sem muito esforço chegamos a solução apresentada na \figref{primeira-solucao}.

  \begin{figure}[h]
    \centering
    \efbox[rightline=false,topline=false,leftline=false,bottomline=false]{
      \makebox[\textwidth]{
        \begin{subfigure}[t]{0.33\textwidth}
          \centering
          \caption{Banco de dados}
          \includegraphics[width=\textwidth]{criar_usuarios.sql.png}
          \label{fig:banco de dados}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.33\textwidth}
          \centering
          \caption{Frontend}
          \includegraphics[width=\textwidth]{raiz.js.png}
          \label{fig:frontend}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.33\textwidth}
          \centering
          \caption{Backend}
          \includegraphics[width=\textwidth]{main.java.png}
          \label{fig:backend-main}
        \end{subfigure}
      }
    }
    \caption{Primeira versão da solução do cenário}
    \small{Fonte: Próprio autor\footnote{Utilizando o serviço https://carbon.now.sh}}
    \label{fig:primeira-solucao}
  \end{figure}

  Sigamos esse método para os demais cenários da \figref{criar-conta.cenarios}.

  Nesse momento, guardadas as devidas proporções, já se pode dizer que o valor imediato esperado pelo patrocinador foi entregue. No entanto, existe muito trabalho pela frente para tornar o produto atraente, muitas funcionalidades precisam ser incorporadas, e como se está utilizando metodologia ágeil, as decisões sobre as histórias de usuário vindouras são tomadas quando estas estiverem sob discussão. Ao contrário do que se costuma fazer em metodologias de desenvolvimento tradicionais, onde uma tentativa de premonição dos problemas a serem enfrentados é realizada, nesse caso é fundamental adotar práticas de desenho arquitetural que permitam extender as capacidades do sistema com o mínimo de trauma possível.

  Aqui entra em cena a atividade de refatoração. Ela permitirá alterar a estrutura interna do software sem que para isso se tenha que alterar o comportamento observável do mesmo. Isso só é possível porque existe uma rede de proteção chamada testes automatizados, que dirão se essa alteração maculou a forma como aquele foi especificado.

  É uma excelente oportunidade, ainda, para diminuir o débito técnico em torno das práticas de testes de unidade\footnote{Deixados de lado para fins didáticos, vez que a abordagem apresentada por \citeonline{FreemanPryce2009} prevê o uso dos mesmos como forma de exercitar a paulatina chegada à solução almejada.}. Também é possível observar que a utilização de testes dessa natureza, ao tempo que garantem um melhor projeto de código para software, não são suficientes para garantir que o mesmo de comporta como esperado - o famoso dilema \emph{fazer a coisa certa vs. fazer certo a coisa}\footnote{\emph{Doing things right} vs. \emph{Doing the right things}, segundo \citeonline{Poddar2018}, o primeiro diz sobre \emph{eficiência} enquanto o segundo se refere a \emph{efetividade}.}. Essa expressão leva a dedução de que os testes de aceitação e os testes de unidade são complementares, e negligenciar qualquer deles é um caminho para o insucesso de qualquer projeto.

  Isso leva a uma ponderação entre prós e contras sobre os tipos de testes. Se por um lado os testes de ponta a ponta permitem afirmar que as funcionalidade solicitadas foram entregues conforme as especificações, também é possível observar que quanto maior é a sua quantidade mais frustrantes é a experiência de utilizá-los como ferramenta de feedback, vez que seu tempo de execução é consideravelmente maior que a de testes de unidade.

  Para ser mais explícito, considere-se os cenários de exceção, da história de usuário em trabalho, onde se espera que os mesmo falhem por invalidade do email e da senha informados. É fácil perceber a necessidade de validar múltiplos valores e, provavelmente, o melhor lugar para fazê-lo não seja nos testes de funcionais, mas naqueles que não requerem acesso a recursos externos.

  Também se pode tirar proveito dessa abordagem para solidificar o entendimento do cerne do negócio (\figref{CriarContaServiceSpec} e \figref{CriarContaService}) e abstrair as dependências que prestam serviços a ele.

  Isso capacita os testes isolados de funcionalidades de mais baixo nível (\figref{EmailValidatorDefaultSpec} e \figref{EmailValidatorDefault}), com o benefício de executarem de maneira celere, tendo como retaguarda os testes de mais alto nível para garantir que tais componentes se integram da forma esperada.

  \begin{figure}[h]
    \centering
    \efbox[rightline=false,topline=false,leftline=false,bottomline=false]{
      \makebox[\textwidth]{
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{CriarContaServiceSpec.png}
          \caption{}
          \label{fig:CriarContaServiceSpec}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{CriarContaService.png}
          \caption{}
          \label{fig:CriarContaService}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{EmailValidatorDefaultSpec.png}
          \caption{}
          \label{fig:EmailValidatorDefaultSpec}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{EmailValidatorDefault.png}
          \caption{}
          \label{fig:EmailValidatorDefault}
        \end{subfigure}
      }
    }
    \caption{Teste de unidade da implementação do caso de uso e da validação de email}
    \small{Fonte: Próprio autor}
    \label{fig:teste-de-unidade-caso-de-uso}
  \end{figure}

	Esse método ainda permite focar a atenção sobre situações que podem ser difíceis de observar quando se verifica o conjunto de maneira holística (\figref{testes-de-integracao-api-e-repositorio}).

  \begin{figure}[h]
    \centering
    \efbox[rightline=false,topline=false,leftline=false,bottomline=false]{
      \makebox[\textwidth]{
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{CriarContaResourceSpec.png}
          \caption{}
          \label{fig:CriarContaResourceSpec}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{CriarContaResource.png}
          \caption{}
          \label{fig:CriarContaResource}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{UsuariosJdbcRepositorySpec.png}
          \caption{}
          \label{fig:UsuariosJdbcRepositorySpec}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{UsuariosJdbcRepository.png}
          \caption{}
          \label{fig:UsuariosJdbcRepository}
        \end{subfigure}
      }
    }
    \caption{Teste de integração de api e repositório}
    \small{Fonte: Próprio autor}
    \label{fig:testes-de-integracao-api-e-repositorio}
  \end{figure}

  A cobertura sobre a especificação é aumentada sem sacrificar o tempo de retroalimentação (\figref{SenhaValidatorDefaultSpec} e \figref{SenhaValidatorDefault}).

  Usando a proposta apresentada por \citeonline[pág. 21]{Hombergs2019}, se faz cumprir a meta de uma arquitetura que grita. Tal exigência é simples de ser visualizada pela árvora de pacotes (\figref{ArvoreBackend}).

  Outra liberdade que se toma, nessa solução em particular, diz respeito a estruturação do código do frontend que, em não sendo uma parte da aplicação para o qual foi delegado muita responsabilidade, foi utilizada uma divisão baseada nas definições de \citeonline{Frost2016}, seja uma \emph{página}, do ponto de vista do usuário, sejam \emph{compoenentes}, que são integrados para formar aquelas (\figref{ArvoreFrontend}).

  Essa estrutura permite testar os componentes e páginas, novamente, de forma isolada (\figref{teste-pagina-registro} e \figref{pagina-registro}), ao passo que são resguardados pelos testes de aceitação.

  \begin{figure}[h]
    \centering
    \efbox[rightline=false,topline=false,leftline=false,bottomline=false]{
      \makebox[\textwidth]{
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{SenhaValidatorDefaultSpec.png}
          \caption{}
          \label{fig:SenhaValidatorDefaultSpec}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{SenhaValidatorDefault.png}
          \caption{}
          \label{fig:SenhaValidatorDefault}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{Registro.spec.js.png}
          \caption{}
          \label{fig:teste-pagina-registro}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{Registro.js.png}
          \caption{}
          \label{fig:pagina-registro}
        \end{subfigure}
      }
    }
    \caption{Teste de unidade de validação de senha e da página de registro no frontend}
    \small{Fonte: Próprio autor}
    \label{fig:testes-de-unidade-validacao-senha}
  \end{figure}

  Outro alvo da metodologia é a "lei" de referência das camadas, onde as mais externas conhecem as mais internas mas o contrário é uma violação arquitetural (\figref{clean-architecture}). De maneira geral, se pode constatar que os componentes do backend formam o desenho proposto por \citeonline{Cockburn2005}, que é uma arquitera limpa, conforme \citeonline[pág. 202]{Martin2018}.

  \begin{figure}[h]
    \centering
    \efbox[rightline=false,topline=false,leftline=false,bottomline=false]{
      \makebox[\textwidth]{
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{ArvoreBackend.png}
          \caption{Frontend}
          \label{fig:ArvoreBackend}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.25\textwidth}
          \centering
          \includegraphics[width=\textwidth]{ArvoreFrontend.png}
          \caption{Backend}
          \label{fig:ArvoreFrontend}
        \end{subfigure}
        \hfill
        \begin{subfigure}[t]{0.5\textwidth}
          \centering
          \includegraphics[width=\textwidth]{CleanArchitecture.jpg}
          \caption{Modelo}
          \label{fig:clean-architecture}
        \end{subfigure}
      }
    }
    \caption{Árvore de pacotes e diretórios da solução e modelo de arquitetura limpa}
    \small{Fonte: Próprio autor e The Clean Code Blog\footnotemark}
    \label{fig:teste-de-unidade-de-pagina-registro}
  \end{figure}
  \footnotetext{\cite{Martin2012}}
