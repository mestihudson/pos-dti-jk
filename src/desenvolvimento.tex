\section{Conceitos básicos}

  Algumas definições são importantes para o bom entendimento do trabalho, sob pena de estabelecer ambiguidades ou equívocos quanto ao que se deseja propor. Sendo assim, no contexto deste trabalho, o que são testes e o que é desenvolvimento guiado por testes? o que é arquitetura de software e o que é uma arquitetura limpa? como desenvolvimento guiado por testes auxilia na obtenção de uma arquitetura limpa?

  \subsection{Testes}

    Se estabelecermos um marco na história da programação como sendo a parceiria entre a matemática londrina Ada Lovelace, e o, também, matemático londrino Charles Babbage \cite{Huskey1980}, pode-se dizer que essa disciplina possui mais de 180 anos, e com ela dois grande problemas: 1. especificar o comportamento de um software; 2. garantir que um software não possua defeitos.

    No primeiro, por mais avanços que se tenha feito no campo da engenharia de software, essa é, ainda, uma área bastante desafiadora. No último, Disjkstra estatuiu que \emph{testes mostram a presença, não a ausência de defeitos} \cite[pág. 16]{Nato1969}.

    Daí a necessidade de se testar \cite[pág. xxix-xxx]{Mezaros2007}: 1. paulatinamente construir conhecimento através da retroalimentação de hipóteses; 2. exaustivamente chegar a um ponto onde não é possível provar a presença de defeitos.

    Testes, segundo os métodos tradicionais de desenvolvimento, são feitos em etapa posterior a sua construção, para \emph{medir qualidade}. Uma abordagem diferente daquela que deseja \emph{construir qualidade} \cite[pág. 7]{FarcicGarcia2015}. Isso reverbera de maneira distinta \emph{quem} os executa: uma equipe independente daquela que construiu o software ou o próprio desenvolvedor?

  \subsection{Desenvolvimento guiado por testes}

    Dentre as práticas que sustentam os métodos ágeis, o uso de testes, como uma atividade de suporte às demais, é um fato consolidado. Mas a abordagem do TDD, também conhecida por \emph{testar primeiro} é ainda mais difundida nesse  meio.

    É bem corriqueiro ver profissionais se referindo à  técnica como "desenvolvimento orientado \emph{a} testes", dando a entender que seu objetivo é produzir um código que seja testável, o que é, claramente, uma consequência do seu uso. Ao passo que uma tradução que melhor exprime o conceito é "desenvolvimento orientado {por} testes".

    A ideia é extremamente simples \cite[p.1]{FreemanPryce2009}: \emph{escrever um teste para um código que ainda não existente}, sumariamente falando, mas de maneira mais completa, trata-se de um ciclo de três etapas \cite[pág. x]{Beck2003} - \figref{ciclo-tdd}: vermelho,  escreva um teste para o qual não existe uma implementação, portanto, não deve estar passando nesse momento; verde, faça o mesmo passar, escrevendo o código da funcionalidade pretendida; refactore, remova duplicações e melhore a legibilidade.

    \imagem
      {scale=0.75}
      {Ciclo de tdd}
      {ciclo-tdd.png}
      {ciclo-tdd}
      {Próprio autor\footnotemark}
    \footnotetext{Baseado na imagem encontrada no blog da Knowledge21 \url{https://knowledge21.com.br/blog/qualidade-de-software-com-tdd-test-driven-development/}}

    Essa postura realoca o papel dos testes de uma atividade meramente focada em descobrir defeitos para uma posição centrada na experiência do usuário, ao \emph{orientar} a desenvolvedora no entendimento das reais necessidades dos primeiros, através de um processo dialético de construção de conhecimento \footnote{\citeonline[p.28]{Oliveira1992} sugere, ao analisar Vygotsky e o processo de formação de conceitos, que os últimos são construções culturais, internalizadas pelos indivíduos ao longo do seu processo de desenvolvimento.}.

    Isso explica porque \citeonline[p.3-5]{FreemanPryce2009} colocam a prática como fundamentada em três pilares: 1. aprendizagem; 2. retroalimentação; e, 3. suporte a mudança.

  \subsection{Arquitetura de software}

    A engenharia de software, enquanto disciplina da ciência dos computadores, recebe o seu primeiro nome graças a uma série de propriedades que lhe são comuns com sua "aparentada" e seu sobrenome, em função de características que lhe são peculiares.

    Tal fenômeno, bastante comum nessa área do conhecimento, explica a denominação da chamada \emph{arquitetura de software} que, na ausência de uma expressão mais apropriada, toma emprestado a alcunha para conceituar uma abordagem com alto nível de abstração, que a "matéria dos dígitos binários" exige.

    Vejamos a definição do verbete inicial da locução: \emph{1. arte de projetar, construir, decorar e oraganizar os espaços de uma edificação; 2. obras arquitetônicas que caracterizam uma época ou povo} \cite[pág. 81]{Kury2007}.

    Ainda, etimologicamente, a palavra remete à composição grega de \emph{ARKHEIN} - que significa \emph{comandar}, em português - com \emph{TEKTON} - que, por sua vez, quer dizer \emph{artesão ou construtor}\footnote{Segundo o sítio "Etimologia - Origem do Conceito: Etimologia de Arquitetura". Disponível em: \url{https://etimologia.com.br/arquitetura/}. Acesso em: 6 de janeiro de 2021.}.

    Por aproximação, diz tratar-se dos dítames direcionadores de uma determinada construção. Ora, não resta dúvida, assim, que arquitetura de software são os preceitos orientadores de um sistema computacional.

  \subsection{Arquitetura limpa}

    Se ao vislumbrar determinada edificação é possível inferir algumas características de uma obra, seria possível realizar o mesmo exercício ao observar um "programa computacional"?

    A depender da forma como um prédio é arquitetado, é factível realizar alterações funcionais sem prejuízo à estrutura, ou, ainda, sem qualquer noção do dano que tais modificações podem desencadear.

    É esperado que a observação da plata baixa de uma edificação transmita informações suficientes para identificar do que se trata - uma casa, uma biblioteca, uma fábrica, etc. Essa é uma qualidade também desejável em um software, que alguns poucos artefatos sejam capazes de esclarecer o proprósito do mesmo. Ela deve \emph{gritar}.

  \citacaolonga
    {Então o que a arquitetura de sua aplicação grita? Quando você olha para o topo da sua estrutura de diretórios, e os arquivos fonte no pacote de mais alto nível, eles gritam "Sistema de Plano de Saúde," ou "Sistema de Contabilidade," ou "Sistema de Gerenciamento de Inventário"? Ou eles gritam "Rails," ou "Spring/Hibernate," ou "ASP"?}
    {\cite[pág. 196, tradução nossa]{Martin2018}}

  Muitos autores, ao longo de seus anos de experiência com desenvolvimento de software, estabeleceram suas próprias noções de arquitetura de sistemas, e apesar de terem nomes distintos - \emph{BCE}\cite{Jacobson1992}, \emph{Hexagonal}\cite{Cockburn2005}, \emph{Onion}\cite{Palermo2008}, \emph{DCI}\cite{Coplien2010} - elas compartilham características que as enquadram no conceito de \emph{Arquitetura Limpa}\cite{Martin2018}, notoriamente: \emph{Independente de frameworks}, \emph{Testável}, \emph{Independente de interface de usuário}, \emph{Independente de banco de dados} e {Independente de qualquer agente externo}.

  Elas também guardam a chamada \emph{Regra da Dependência}, onde, segundo \citeonline[p. 197, tradução nossa]{Martin2018} "as dependências do código fonte deve apontar somente na direção do centro do círculo, rumo as políticas de alto nível", como pode ser observado na \figref{clean-architecture}.

  \imagem
    {scale=0.4}
    {Modelo de Arquitetura Limpa}
    {CleanArchitecture.jpg}
    {clean-architecture}
    {\cite[pág. 197]{Martin2018}}

  \subsection{Como o desenvolvimento guiado por testes auxilia na obtenção de uma arquitetura limpa?}

    É fácil encontrar muitas similaridades entre a arquitetura convencional e a de software, mas existe um quesito que pesa a favor da última: como o nome sugere, soft (em português: flexível, suave) é um bem intangível, cuja construção, guardadas as devidas proporções e contextos, não oferece os mesmos riscos, por vezes irreparáveis, que a primeira está sujeita.

    Desenvolvimento guiado por testes privilegia uma conduta que permite definir as funções essenciais do sistema, implementá-las da maneira mais simplória conhecida e através de sucessivas modificações, amparadas por uma rede de proteção que previne regressões, alcançar um modelo que expressa, claramente, quais seus objetivos e permite uma evolução sustentável do produto.

\section{Trabalhos relacionados}

  \citeonline{Aniche2012} sugere que é possível inferir que \emph{Test-Driven Development} (TDD) é uma prática de testes de software mas relembra que muitos autores, da academia e da indústria, reconhecem que seus benefícios se extendem para outras áreas, como o projeto de classes, levando ao que se espera de tais - fracamente acopladas e fortemente coesas. Essa constatação vem em contraposição à escassez de trabalhos voltados a apresentar \emph{como} essas capacidades são alcançadas pelo uso da técnica vez que a maioria se preocupa em demonstrar \emph{se} a prática faz diferença na qualidade do código. Ele propõe uma melhor compreensão dos efeitos do TDD e de que maneira seu exercício interfere sobre como o desenvolvedor projeta os sistemas orientados a objetos. É um estudo exploratório de base fundamentalmente qualitativo onde os envolvidos são chamados a solucionar problemas pré-estabelecidos utilizando TDD, de onde dados são colhidos para levantar detalhes a respeito de como isso manipulou as decisões do projeto de classes dos entrevistados.

  \citeonline{Milanez2014} considera que o desenvolvimento de programas de computador é uma atividade de alta complexidade, que apresenta dificuldades variadas quanto as estimativas de custo e prazo, desafiada por uma constante mudança nos requisitos, que geram resultados cujas prerrogativas de comportamento adequado são poucas ou inexistentes. Afirma, ainda, que "não há teoria que que estabeleça as bases de conhecimentos necessários a prover soluções a estes problemas". Lembra que muitas tentativas foram realizadas durante muitos anos no intuíto de propor evoluções, o que levou ao desenvolvimento de diversas linguagens de programação, processos e técnicas de desenvolvimento. Como resposta a esses problemas, reconhece que TDD se impõe como uma alternativa. Mas anuncia que tal técnica é incapaz de derivar implementações partindo de uma gama de requisitos levantados e elicitados. Identificando esse flanco aberto, indica uma complementação nas orientações de Kent Beck, através da introdução de uma fase intermediária pelo uso de modelos guiados por casos de uso.

  \citeonline{Santos2015} atribui o surgimento dos métodos ágeis de desenvolvimento de software, em opção aos métodos tradicionais, à necessidade de empreender menos esforço com documentação e mais com a solução de problemas pelo uso de uma abordagem que privilegie a troca de experiências e que construam conhecimento de maneira incremental. Dentre tais métodos, destaca que \emph{Domain-Driven Design} (DDD) intui um processo orientado pelo modelo de domínio. Salienta, igualmente, que a qualidade do resultado deve ser garantida, e que o fazimento de testes durante a implementação é capaz de efetivá-la. Assim, através do framework Apache Isis, o estudo de caso visa ilustrar a agregação de TDD e DDD. Dele se concluiu que a união das técnicas potencializou o desenvolvimento de aplicações, posto que o primeiro não define uma técnica específica de testes ao passo que utilizar a linguagem ubíqua para a construção dos cenários criou grande diferencial à última.

  \citeonline{Aguilar2016} reconhece que teste é um método efetivo para avaliar e melhorar a qualidade do software, ao tempo em que inclui TDD no rol daquele, conceituando este último como e informando que na Islândia tal atividade nunca recebeu atenção merecida, em contraposição ao que ocorre em outros países. Seu trabalho propõe uma investigar os pontos positivos e negativos da técnica comparando e analizando o que os desenvolvedores islandeses experimentaram quando a utilizaram e quando não o fizeram. Para tanto o estudo apresenta resultados de sete entrevistas semi-estruturadas com praticantes que estavam trabalhando em projetos de software na indústria daquele país que faziam uso delas. Os resultados demonstraram que TDD é capaz de ajudar seus praticantes a melhorar seus resultados de implementação de diversas formas. Como principais vantagens de sua adoção podem ser salientadas: melhora na qualidade do código, diminui a quantidade de defeitos, facilita a manutenção, cria uma rede de proteção e aumenta a confiabilidade do produto.

  \citeonline{Gustavsson2017} relembra que TDD tem sido alvo de muitos outros trabalhos em que os autores tentam revelar o impacto da técnica comparada ao modelo tradicional de desenvolvimento - que ele denomina ITL (Iterative Test-Last ou, testar depois ainda que frequentemente, em uma tradução livre). Diz ainda que tais autores seguem, geralmente, ou uma abordagem acadêmica ou uma industrial que foca em métricas de pouca relevância para o mercado. Cita algumas dessas métricas - Densidade de Defeitos por 1000 linhas de código (DD/KLOC) e Complexidade Ciclomática de McCabe - como sendo frequentemente usadas para comparar as diferenças entre ITL e TDD. Mas ressalta que tais são desatualizadas e irrelevantes com a chegada de linguagens de alto-nível como Java, C\# e Python. Ele sugere uma nova métrica - Densidade de Defeitos por Hora (DD/h) - e argumenta que é uma forma melhor de medir pois não depende de linguagem de programação ou de complexidade, como ocorre com o DD/KLOC.

  \cite{Adhikari2019}

  \cite{Benato2021}
  Uma outra abordagem é utilizada por \citeonline{Benato2021}, que apresenta uma revisão bibliográfica de trabalhos publicados entre 2003 e 2020 para contrastar os resultados obtidos pelo uso de \emph{test-first} e \emph{test-last}.

  \cite{Beltrao2020}
  Em \citeonline{Beltrao2020}, é possível acompanhar os autores tentando manter uma trilha da dívida técnica de um projeto de software através da ferramenta \emph{SonarQube} e idetificarem a necessidade de implementar regras específicas para as características de uma \emph{Arquitetura Limpa} naquela ferramenta de forma apoiar as ações necessárias para alcançar tal estrutura de código.

  \cite{Souza2021}
  Por fim, \citeonline{Souza2021}, leva o leitor pelo desenvolvimento de um software real cujo resultado revela a presença dos atributos esperados por uma arquitera limpa.

\section{O problema sob foco}

  O objetivo é construir uma aplicação onde um usuário qualquer possa se registrar para adquirir acesso. Uma vez autenticado ele pode propor ou responder a uma proposta de partida com um adversário que tenha realizado o mesmo caminho. E, obviamente, desempenhar uma partida. Deve, ainda, ser possível, organizar torneios, visualizar uma lista de classificação dos jogadores por suas respectivas pontuações e, apenas, observar uma partida, sem dela participar. É desejável que o registro e a autenticação possam ser realizados utilizando os mecanismos ofertados pelo Google e Facebook, bem como retomar uma partida que foi explicita ou implicitamente suspensa (um dos jogadores pode ter perdido a conexão por problemas em sua rede). Os jogadores devem ser capazes de convidar um adversário específico para uma partida. Também seria interessante que os usuários possam recuperar suas senhas que, ocasionalmente, possam vir a esquecer ou alterar informações sobre si (como nome que é apresentado aos demais, imagem de perfil, etc) além, é claro, de poder remover sua conta, caso não tenha mais interesse no serviço.

  Essa é uma descrição hipotética de necessidade inicial de um interessado em patrocinar um projeto dessa qualidade. Claro, em uma situação real, muitos outros detalhes deveriam ser capturados para refinar a solução, mas aqui vamos partir da premissa que esta é nossa única demanda.

  \subsection{O jogo}

    Hive\footnotemark é um jogo abstrato de duelo, tal qual o xadrez, onde os jogadores devem usar seus respectivos acervos para cercar o alvo oponente.
    \footnotetext{Tradução e adaptação nossa do sítio "UltraBoardGames: How to Play Hive". Disponível em: \url{https://www.ultraboardgames.com/hive/game-rules.php}. Acesso em: 29 de janeiro de 2021.}

    Cada jogador possui onze peças em formato hexagonal de cinco tipos distintos, cada tipo sendo representado por um inseto: uma abelha rainha, o alvo; duas aranhas; dois besouros; três gafanhotos; e, três formigas.

    Apenas uma ação, das duas possíveis, é permitida aos jogadores executar por turno: entrada e movimentação.

    Quando entra em jogo, uma peça deve ser colocada adjacente a uma que já está, à exceção daquela colocada no primiero turno do jogo. Ela também não deve tocar nenhuma peça adversária, reservada aquela que o faz no segundo turno, posto que a regra anterior deve ser atendida.

    A abelha rainha deve entrar, no máximo, até a quarta rodada. Enquanto isso não ocorrer, nenhuma peça irmã poderá ser movimentada.

    Os insetos tem movimentações diversas. A abelha rainha, um passo por vez ao redor da colméia. As aranhas, três passos ao redor da colméia, sempre na mesma direção iniciada. Os besouros, um passo ao redor da colméia ou acima dela, e a peça sob o qual ele pousa fica imobilizada até que ele a deixe e, para efeito de novas entradas, a posição ocupada assume a cor do mesmo. Os gafanhotos, se movimentam sobre a colméia, iniciando de um lado e seguindo em linha reta (perpendicular a aresta escolhida) até o lado oposto. E,  as formigas, o fazem ao redor da colméia sem limites de passos. Tais ações não podem resultar em uma colméia fragmentada, mesmo que o resultado seja uma colméia intacta. As movimentações ao redor devem ser de livre deslize, não sendo permitido entrar em uma posição onde isso não é possível.

    Finalmente, a abelha rainha é considerada cercada quando todos os seus lados estão ocupados por alguma peça em jogo, independente de a quem elas pertençam.

\section{A proposta de solução}

  Em função das limitações de tamanho e tempo, observou-se uma oportunidade para utilização de abordagem baseada em metodologias ágeis. No entanto, não é objetivo discorrer sobre o andamento de um projeto de software em sua completude mas, focar em algumas técnicas de desenvolvimento utilizadas. De tal forma, contamos com uma certa indulgência do leitor no que se refere a omissões descritivas dos caminhos gerenciais tomados.

  Usando \emph{histórias de usuário} como mecanismo para levantamento das necessidades preliminares, se chega a um número bem razoável delas donde, para priorizar as que trazem mais valor ao negócio, se faz necessário organizar as mesmas dentro de um ciclo de capacidade mínimo, momento oportuno para utilizar a técnica nomeada por \citeonline{Patton2014} de \emph{Mapeamento de Histórias de Usuário}, bastante útil para identificar fluxos e definir sua importância, em particular para o contexto em que não existe um proprietário de projeto - PO - capaz de organizá-las e completar as intenções firmadas no escopo, como pode ser conferido na \figref{mapeamento-historias-usuario}.

  \imagem
    {height=7cm,width=16cm}
    {Mapeamento de histórias de usuário}
    {mapeamento-historias-de-usuario.miro}
    {mapeamento-historias-usuario}
    {Próprio autor\footnotemark}
  \footnotetext{Utilizando a ferramenta/serviço \url{https://miro.com/}}

  Foram identificadas 7 (sete) histórias essenciais: \emph{criar conta; entrar; sair; chamar partida; atender chamado para partida; colocar peça em jogo; e, movimentar peça}. Isso define a abrangência do \emph{lançamento}\cite[tradução nossa]{Beck2001}. Durante análise das histórias, percebe-se que algumas delas tem característicasde \emph{épicos}\cite[pág. 6, tradução nossa]{Cohn2004}, por si só, mas, para evitar a \emph{paralisia de análise}\cite[pág. 71, tradução nossa]{Pugh2011}, é adequado procrastinar a decisão de \emph{dividí-la}\cite[pág. 24, tradução nossa]{Cohn2004}, até que cada uma seja laborada especificamente. Esse sentimento também ajuda a escolher, para a primeira interação, a história de usuário \emph{Criar conta}.

  Factualmente, existem duas escolas de TDD: \emph{Chicago} - encontrada, ainda, como inside-out (de dentro para fora), classicista, bottom-up (de baixo para cima) - e \emph{Londres} - também conhecida como outside-in (de fora para dentro), mockista, top-down (de cima para baixo). Segundo \citeonline[págs. 488-492] {BryantPerez2019}, a tecnologia utilizada, mecanismos de construção, habilidades e preferências pessoais irão determinar que abordagem escolher. Mas também cita algumas características que ajudam nesta: possui bem delineadas as regras do negócio ou terá que traduzir o processo dos interessados em regras que possam ser automatizadas; existem restrições de plataforma (deve ser uma aplicação web, deve usar um determinado servidor de banco de dados, etc).

  Sendo assim, optamos pela abordagem londrina, que tem como principais representantes \citeonline{FreemanPryce2009}. A primeira observação é sobre o ciclo que, nessa perspectiva, possui dois níveis de execução - \figref{ciclo-atdd}. Graças a isso, é esperado que a etapa mais externa permanesça por mais tempo em estado de falha.

  \imagem
    {height=8cm,width=\textwidth}
    {Duplo ciclo da escola londrina de tdd}
    {ciclo-atdd.png}
    {ciclo-atdd}
    {\cite[pág. 40, tradução nossa]{FreemanPryce2009}\footnotemark}
  \footnotetext{Utilizando a ferramenta/serviço \url{https://draw.io}}

  Também é preciso definir um esboço estrutural dos componentes de auto nível - \figref{esboco-estrutural} - sobre o qual repousará a solução (inicialmente - pois ela pode, ou não, vir a ser modificado durante o transcorrer do projeto).

  \imagem
    {scale=0.5}
    {Esboço estrutural dos componentes da solução}
    {esboco-estrutural.png}
    {esboco-estrutural}
    {Própio autor\footnotemark}
  \footnotetext{Utilizada a ferramenta/serviço \url{https://draw.io}.}

  Para levantar as histórias, \citeonline{Cohn2004} sugere o seguinte método:
  \begin{itemize}
    \item Identificar os papéis/personas envolvidos;
    \item Utilizá-los para construir narrativas no formato \emph{Connextra}\footnote{\citeonline{Connextra2001} propõe um modelo baseado na tríade \emph{papel-funcionalidade-benefício} ou, mais explicitamente, \narrativa{papel}{uma funcionalidade}{conseguir um benefício}};
    \item Levantar os critérios de aceite de cada história.
  \end{itemize}

  Com a história \emph{Criar conta} se chega a seguinte narrativa: \narrativa{visitante}{criar uma conta}{entrar e jogar uma partida}.

  Também são levantados os seguintes critérios de aceite:
  \begin{itemize}
    \item Deve ser informado um email válido;
    \item Deve ser informada uma senha de tamanho mínimo 8 (oito) e tamanho máximo 20 (vinte) caracteres;
    \item Não deve ser possível criar uma conta para um email que já vinculado a uma outra conta;
    \item Deve constar um registro persistente ao final do processo.
  \end{itemize}

  Já há elementos para elencar os cenários a serem trabalhados\footnote{Código disponível em: \url{https://github.com/mestihudson/hive/blob/pre-refactoring/e2e/features/registro/criar-conta.feature}.}. Também é possível detalhar os passos de cada um deles usando o método sugerido por \citeonline{Nicieja2018} para derivação a partir dos critérios de aceite. O formato, \emph{Gherkin}, se baseia no celebre artigo escrito por \citeonline{North2006}.

  Essa estrutura se alicerça na seguinte ideia: o passo identificado por \textbf{Dado} define o \emph{contexto} - pré-condição - onde a \emph{ação} (\textbf{Quando}) deve acontecer para que o \emph{resultado esperado} - pós-condição - (\textbf{Então}) seja observado.

  Há de salientar que os passos dos cenários descritos são, suficientemente, abstratos para permitir que os não-técnicos o leiam (ou, ainda, desejavelmente, os escrevam) mas não tanto que inviabilizar a sua automatização. Construímos o que \citeonline[pág. 24]{Evans2003} chama de \emph{linguagem ubíqua}. Dentre outros benefícios se pode citar a não \emph{fragilidade}\cite[pág. 93, tradução nossa]{RoseWynneHellesoy2015} desses artefatos, tornando-os resilientes às alterações de implementação, enquanto o comportamento esperado se mantiver intacto. Essa característica é essencial para subsidiar a \emph{refatoração} pois:

  \citacaolonga
    {Quando eu faço uma refatoração, o primeiro passo é sempre o mesmo. Eu preciso construir um sólido conjunto de testes para aquela seção de código. Os testes são essenciais por que muito embora eu siga refatorações estruturadas para evitar muitas das oportunidades de introduzir defeitos, eu ainda sou humano e ainda cometo erros. Assim eu necessito de testes sólidos.}
    {\cite[p.  17, tradução nossa]{Fowler1999}}

  Que por sua vez, é condição para o alvo mirado, a \emph{Arquitetura Limpa}.

  Retomando o esboço estrutural, ele é enriquecido com os componentes que substituirão a figura humana no processo, dando \emph{vida à documentação} \cite[pág. 29, tradução nossa]{Adzic2011}, conforme \figref{esboco-estrutural-enriquecido}.

  \imagem
    {height=6cm}
    {Esboço estrutural enriquecido com os componentes que permitem a automatização}
    {esboco-estrutural-enriquecido.png}
    {esboco-estrutural-enriquecido}
    {Própio autor}

  Existem muitos mitos em torno das metodologias ágeis, e uma delas é a não existência de modelagem. Essa falsa crença se dá, muitas vezes, por uma noção equivocada de que documentação e modelos são equivalentes. \citeonline{Ambler2002} desconstrói esses mitos e mostra que essa atividade é, além de possível, basilar para um bom projeto de software. Isso permite, por exemplo, rabiscar uma solução para o cenário descrito \cite[pág. 57]{Ruby2011}, ainda bem pasteurizado na \figref{modelo-solucao.criar-conta-deve-ser-bem-sucedido.jpeg}.

  \imagem
    {scale=0.3}
    {Modelo visual para solucionar o \textbf{cenário} \emph{deve ser bem sucedido} da \textbf{história} \emph{Criar conta}}
    {modelo-visual-cenario.png}
    {modelo-solucao.criar-conta-deve-ser-bem-sucedido.jpeg}
    {Própio autor\footnotemark}
  \footnotetext{Utilizada a ferramenta/serviço \url{https://draw.io}.}

  Esse ponto é auxiliado pelo que \citeonline[págs. 142 e 226]{Abelson1996} chama de \emph{wishful thinking}\footnote{Pensamento positivo, em tradução livre.} - mais precisamente o que \citeonline[pág. 45]{Astels2003} denomina \emph{programar por intenção} - para implementar os passos do cenário apresentados como se a funcionalidade pretendida já existisse. O objetivo é ser o mais claro possível sobre o que se almeja com aquela especificação\footnote{O resultado pode ser visto em \url{https://github.com/mestihudson/hive/blob/pre-refactoring/e2e/steps/all.steps.js}.}.

  Essa etapa pode divergir bastante entre os diversos autores que tratam do tema, no que tange os conceitos de \emph{baby steps} \cite[pág. 1]{Aniche2011}, \emph{iniciar pelas verificações}, \emph{usar somente uma asserção por cenário}, \emph{não usar asserções fora da fase de verificação}. No fim, prevalecem, \emph{a familiaridade com as tecnologias empregadas}, \emph{a experiência no processo de desenvolvimento guiado por testes}, \emph{a simplicidade} \cite[pág. xii]{Beck2003}, mas, principalmente, \emph{o bom senso}.

  % Como dito antes, o modelo londrino supõe a ciência prévia de determinados componentes da solução, de tal forma que o código da especificação funciona como uma tela de proteção no picadero de um circo funciona para os artistas do trapézio. Esse, talvez, seja o motivo de, algumas vezes, se tomar atalhos como o não uso de testes unitários em cenários em que, pela experiência, não apresentam grandes desafios. Ou seja, o desenvolvedor sabe o que quer fazer, mas para evitar horas procurando uma vírgula mal colocada, ele se utiliza da espeficifação automatizada para validar o caminho que ele está tomando. Essa mesma, lhe garantirá a não regressão de um caso, no momento em que um caminho mais elegante, internamente falando, for imaginado.

  Para este cenário, em particular, vemos, claramente, 2 componentes fundamentais: entrada de dados - ui (interface de usuário, mas poderia ser uma interface de código, se nossa solução fosse destinada a outros sistemas ao invés de humanos); e, saída de dados - db (que poderia envolver outros atores, como, por exemplo, um servidor de envio de mensagens eletrônicas externo, caso fossemos exigir ativação da conta por algum link encaminhado por email).

  Espera-se que, ao final da execução deste caso de teste, durante a verificação dos \emph{resultados esperados}, tenha-se um registro que comprove que a entrada de dados foi devidamente persistida. Isso deve ocorrer em contraposição ao \emph{contexto} do teste, em que o dito registro não deve existir. Assim o primeiro passo na direção da completude do cenário é a criação da consulta que faz a verificação da ausência do registro na base de dados\footnote{Conforme \url{https://github.com/mestihudson/hive/blob/pre-refactoring/e2e/steps/DB.js}.}.

  Para o passo que representa a ação, vemos que existem níveis de abstração, ao observar que o comando \emph{quando eu me registro}, na verdade é uma composição de 3 ações: abrir a página do formulário de registro; preencher os campos obrigatórios do mesmo (que, por si só, já é uma composição pois resume o preenchimento de muitos campos a uma única ação composta); e, finalmente, submeter essas informações pelo clique no botão \emph{registrar}\footnote{Como verificável em \url{https://github.com/mestihudson/hive/blob/pre-refactoring/e2e/steps/UI.js}.}.

  Por fim, temos o passo de verificação, como já havíamos adiantado, reutilizamos o código de suporte da pré-condição que deve ter o efeito oposto nesse momento, bem como a da existência de uma mensagem de feedback do sucesso da ação\footnote{Tal qual já apresentado em \url{https://github.com/mestihudson/hive/blob/pre-refactoring/e2e/steps/DB.js}.}.

  Isso conclui o trabalho de construção da rede de proteção que nos permitirá implementar a funcionalidade com a confiança de que seremos apoiados pela especificação automatizada. Desse momento em diante, podemos, inclusive, escolher a plataforma que melhor nos convier (desde que atenda aos limites mínimos impostos, que nesse caso são: uma aplicação web e um banco de dados relacional suportado pela plataforma). Ou seja, a miriade de possibilidades em que essa solução pode ser implementada é enorme. Para o nosso caso, em particular, escolhemos um frontend em React e um backend em Java/Quarkus e um banco de dados PostgreSQL\footnote{Sem muito esforço chegamos a solução apresentada em: \url{https://github.com/mestihudson/hive/blob/pre-refactoring/api/src/main/resources/db/migration/V1.0.0__criar_tabela_usuarios.sql}, \url{https://github.com/mestihudson/hive/blob/pre-refactoring/api/src/main/java/hive/Main.java} e \url{https://github.com/mestihudson/hive/blob/pre-refactoring/app/src/Raiz.js}.}

  Esse mesmo método é seguido para os demais cenários\footnote{Para conferir, \url{https://github.com/mestihudson/hive/blob/pre-refactoring/e2e/features/registro/criar-conta.feature}.}.

  Nesse momento, guardadas as devidas proporções, já se pode dizer que o valor imediato esperado pelo patrocinador foi entregue. No entanto, existe muito trabalho pela frente para tornar o produto atraente, muitas funcionalidades precisam ser incorporadas, e como se está utilizando metodologia ágeil, as decisões sobre as histórias de usuário vindouras são tomadas quando estas estiverem sob discussão. Ao contrário do que se costuma fazer em metodologias de desenvolvimento tradicionais, onde uma tentativa de premonição dos problemas a serem enfrentados é realizada, nesse caso é fundamental adotar práticas de desenho arquitetural que permitam extender as capacidades do sistema com o mínimo de trauma possível.

  Aqui entra em cena a atividade de refatoração. Ela permitirá alterar a estrutura interna do software sem que para isso se tenha que alterar o comportamento observável do mesmo. Isso só é possível porque existe uma rede de proteção chamada testes automatizados, que dirão se essa alteração maculou a forma como aquele foi especificado.

  É uma excelente oportunidade, ainda, para diminuir o débito técnico em torno das práticas de testes de unidade\footnote{Deixados de lado para fins didáticos, vez que a abordagem apresentada por \citeonline{FreemanPryce2009} prevê o uso dos mesmos como forma de exercitar a paulatina chegada à solução almejada.}. Também é possível observar que a utilização de testes dessa natureza, ao tempo que garantem um melhor projeto de código para software, não são suficientes para garantir que o mesmo de comporta como esperado - o famoso dilema \emph{eficácia} vs. \emph{eficiência}.

  A primeira se refere a produzir com sucesso o resultado esperado ou desejado; é o grau em que você alcança seus objetivos, resolve problemas e percebe ganhos. É \emph{fazer a coisa certa}.
      A última é a realização de um trabalho com menor desprendimento de tempo, esforço e custo. É \emph{fazer a coisa do jeito certo}.\cite[p.2, tradução nossa]{Stack2016}

  Desse embate é possível concluir que testes de integração (aceitação, ponta a ponta, etc) e testes de unidade são complementares, e negligenciar qualquer deles é um caminho para o insucesso de qualquer projeto.

  Isso leva a uma ponderação entre prós e contras sobre os tipos de testes. Se por um lado os testes de ponta a ponta permitem afirmar que as funcionalidade solicitadas foram entregues conforme as especificações, também é possível observar que quanto maior é a sua quantidade mais frustrantes é a experiência de utilizá-los como ferramenta de feedback, vez que seu tempo de execução é consideravelmente maior que a de testes de unidade.

  Para ser mais explícito, considere-se os cenários de exceção, da história de usuário em trabalho, onde se espera que os mesmo falhem por invalidade do email e da senha informados. É fácil perceber a necessidade de validar múltiplos valores e, provavelmente, o melhor lugar para fazê-lo não seja nos testes de funcionais, mas naqueles que não requerem acesso a recursos externos\footnote{Como demostrado em \url{https://github.com/mestihudson/hive/blob/post-refactoring/api/src/test/java/unit/hive/registro/domain/EmailValidatorDefaultSpec.java}.}

  Também se pode tirar proveito dessa abordagem para solidificar o entendimento do cerne do negócio\footnote{Já citado em \url{https://github.com/mestihudson/hive/blob/pre-refactoring/e2e/features/registro/criar-conta.feature}.} e abstrair as dependências que prestam serviços a ele\footnote{Registrado em \url{https://github.com/mestihudson/hive/blob/post-refactoring/api/src/test/java/unit/hive/registro/application/CriarContaServiceSpec.java}.}.

  Isso capacita os testes isolados de funcionalidades de mais baixo nível\footnote{Como as regras de validação de senha \url{https://github.com/mestihudson/hive/blob/post-refactoring/api/src/test/java/unit/hive/registro/domain/SenhaValidatorDefaultSpec.java}.}, e com o benefício de executarem de maneira celere, tendo como retaguarda os testes de mais alto nível para garantir que tais componentes se integram da forma esperada.

  Esse método ainda permite focar a atenção sobre situações que podem ser difíceis de observar, como a integração com um banco de dados\footnote{Empenhado em \url{https://github.com/mestihudson/hive/blob/post-refactoring/api/src/test/java/integration/hive/registro/adapters/out/persistence/UsuariosJdbcRepositorySpec.java}.}.

  Ou que tendem a ser camufladas por outras razões, como o tratamento de entradas por uma api rest\footnote{\url{https://github.com/mestihudson/hive/blob/post-refactoring/api/src/test/java/integration/hive/registro/adapters/in/web/CriarContaResourceSpec.java}.}, quando se verifica o conjunto de maneira holística.

  A cobertura sobre a especificação é aumentada sem sacrificar o tempo de retroalimentação.

  Usando a proposta apresentada por \citeonline[pág. 21]{Hombergs2019}, se faz cumprir a meta de uma arquitetura que grita. Tal exigência é simples de ser visualizada pela árvora de pacotes - \figref{ArvoreBackend}.

  Outra liberdade que se toma, nessa solução em particular, diz respeito a estruturação do código do frontend que, em não sendo uma parte da aplicação para o qual foi delegado muita responsabilidade, foi utilizada uma divisão baseada nas definições de \citeonline{Frost2016}, seja uma \emph{página}, do ponto de vista do usuário, sejam \emph{compoenentes}, que são integrados para formar aquelas - \figref{ArvoreFrontend}.

  \begin{figure}[htb!]
    \centering
    \efbox[rightline=false,topline=false,leftline=false,bottomline=false]{
      \makebox[\textwidth]{
        \begin{subfigure}[htb!]{0.5\textwidth}
          \centering
          \includegraphics[width=0.9\textwidth]{backend-package-tree.png}
          \caption{Backend}
          \label{fig:ArvoreBackend}
        \end{subfigure}
        \hfill
        \begin{subfigure}[htb!]{0.5\textwidth}
          \centering
          \includegraphics[width=0.9\textwidth]{frontend-package-tree.png}
          \caption{Frontend}
          \label{fig:ArvoreFrontend}
        \end{subfigure}
      }
    }
    \caption{Árvore de pacotes e diretórios da solução}
    \small{Fonte: Próprio autor}
  \end{figure}

  Essa estrutura permite testar os componentes e páginas, novamente, de forma isolada\footnote{Também registrado em \url{https://github.com/mestihudson/hive/blob/post-refactoring/app/test/unit/paginas/Registro.spec.js}.}, ao passo que são resguardados pelos testes de aceitação.

  Outro alvo da metodologia é a "lei" de referência das camadas, onde as mais externas conhecem as mais internas mas o contrário é uma violação arquitetural - \figref{clean-architecture}. De maneira geral, se pode constatar que os componentes do backend formam o desenho proposto por \citeonline{Cockburn2005}, que é uma arquitera limpa, conforme \citeonline[pág. 202]{Martin2018}.
