\section{Conceitos básicos}

  Algumas definições são importantes para o bom entendimento do trabalho, sob pena de estabelecer ambiguidades ou equívocos quanto ao que se deseja propor. Sendo assim, no contexto deste trabalho, o que são testes e o que é desenvolvimento guiado por testes? o que é arquitetura de software e o que é uma arquitetura limpa? como desenvolvimento guiado por testes auxilia na obtenção de uma arquitetura limpa?

  \subsection{Testes}

    Se estabelecermos um marco na história da programação como sendo a parceiria entre a matemática londrina Ada Lovelace, e o, também, matemático londrino Charles Babbage \cite{Huskey1980}, pode-se dizer que essa disciplina possui mais de 180 anos, e com ela dois grande problemas: 1. especificar o comportamento de um software; 2. garantir que um software não possua defeitos.

    No primeiro, por mais avanços que se tenha feito no campo da engenharia de software, essa é, ainda, uma área bastante desafiadora. No último, Disjkstra estatuiu que \emph{testes mostram a presença, não a ausência de defeitos} \cite[pág. 16]{Nato1969}.

    Daí a necessidade de se testar \cite[pág. xxix-xxx]{Mezaros2007}: 1. paulatinamente construir conhecimento através da retroalimentação de hipóteses; 2. exaustivamente chegar a um ponto onde não é possível provar a presença de defeitos.

    Testes, segundo os métodos tradicionais de desenvolvimento, são feitos em etapa posterior a sua construção, para \emph{medir qualidade}. Uma abordagem diferente daquela que deseja \emph{construir qualidade} \cite[pág. 7]{FarcicGarcia2015}. Isso reverbera de maneira distinta \emph{quem} os executa: uma equipe independente daquela que construiu o software ou o próprio desenvolvedor?

  \subsection{Desenvolvimento guiado por testes}

    Dentre as práticas que sustentam os métodos ágeis, o uso de testes, como uma atividade de suporte às demais, é um fato consolidado. Mas a abordagem do TDD, também conhecida por \emph{testar primeiro} é ainda mais difundida nesse  meio.

    É bem corriqueiro ver profissionais se referindo à  técnica como "desenvolvimento orientado \emph{a} testes", dando a entender que seu objetivo é produzir um código que seja testável, o que é, claramente, uma consequência do seu uso. Ao passo que uma tradução que melhor exprime o conceito é "desenvolvimento orientado {por} testes".

    A ideia é extremamente simples \cite[p.1]{FreemanPryce2009}: \emph{escrever um teste para um código que ainda não existente}, sumariamente falando, mas de maneira mais completa, trata-se de um ciclo de três etapas \cite[pág. x]{Beck2003} - \figref{ciclo-tdd}: vermelho,  escreva um teste para o qual não existe uma implementação, portanto, não deve estar passando nesse momento; verde, faça o mesmo passar, escrevendo o código da funcionalidade pretendida; refactore, remova duplicações e melhore a legibilidade.

    \imagem
      {scale=0.75}
      {Ciclo de tdd}
      {ciclo-tdd.png}
      {ciclo-tdd}
      {Próprio autor\footnotemark}
    \footnotetext{Baseado na imagem encontrada no blog da Knowledge21 \url{https://knowledge21.com.br/blog/qualidade-de-software-com-tdd-test-driven-development/}}

    Essa postura realoca o papel dos testes de uma atividade meramente focada em descobrir defeitos para uma posição centrada na experiência do usuário, ao \emph{orientar} a desenvolvedora no entendimento das reais necessidades dos primeiros, através de um processo dialético de construção de conhecimento \footnote{\citeonline[p.28]{Oliveira1992} sugere, ao analisar Vygotsky e o processo de formação de conceitos, que os últimos são construções culturais, internalizadas pelos indivíduos ao longo do seu processo de desenvolvimento.}.

    Isso explica porque \citeonline[p.3-5]{FreemanPryce2009} colocam a prática como fundamentada em três pilares: 1. aprendizagem; 2. retroalimentação; e, 3. suporte a mudança.

  \subsection{Arquitetura de software}

    A engenharia de software, enquanto disciplina da ciência dos computadores, recebe o seu primeiro nome graças a uma série de propriedades que lhe são comuns com sua "aparentada" e seu sobrenome, em função de características que lhe são peculiares.

    Tal fenômeno, bastante comum nessa área do conhecimento, explica a denominação da chamada \emph{arquitetura de software} que, na ausência de uma expressão mais apropriada, toma emprestado a alcunha para conceituar uma abordagem com alto nível de abstração, que a "matéria dos dígitos binários" exige.

    Vejamos a definição do verbete inicial da locução: \emph{1. arte de projetar, construir, decorar e oraganizar os espaços de uma edificação; 2. obras arquitetônicas que caracterizam uma época ou povo} \cite[pág. 81]{Kury2007}.

    Ainda, etimologicamente, a palavra remete à composição grega de \emph{ARKHEIN} - que significa \emph{comandar}, em português - com \emph{TEKTON} - que, por sua vez, quer dizer \emph{artesão ou construtor}\footnote{Segundo o sítio "Etimologia - Origem do Conceito: Etimologia de Arquitetura". Disponível em: \url{https://etimologia.com.br/arquitetura/}. Acesso em: 6 de janeiro de 2021.}.

    Por aproximação, diz tratar-se dos dítames direcionadores de uma determinada construção. Ora, não resta dúvida, assim, que arquitetura de software são os preceitos orientadores de um sistema computacional.

  \subsection{Arquitetura limpa}

    Se ao vislumbrar determinada edificação é possível inferir algumas características de uma obra, seria possível realizar o mesmo exercício ao observar um "programa computacional"?

    A depender da forma como um prédio é arquitetado, é factível realizar alterações funcionais sem prejuízo à estrutura, ou, ainda, sem qualquer noção do dano que tais modificações podem desencadear.

    É esperado que a observação da plata baixa de uma edificação transmita informações suficientes para identificar do que se trata - uma casa, uma biblioteca, uma fábrica, etc. Essa é uma qualidade também desejável em um software, que alguns poucos artefatos sejam capazes de esclarecer o proprósito do mesmo. Ela deve \emph{gritar}.

  \citacaolonga
    {Então o que a arquitetura de sua aplicação grita? Quando você olha para o topo da sua estrutura de diretórios, e os arquivos fonte no pacote de mais alto nível, eles gritam "Sistema de Plano de Saúde," ou "Sistema de Contabilidade," ou "Sistema de Gerenciamento de Inventário"? Ou eles gritam "Rails," ou "Spring/Hibernate," ou "ASP"?}
    {\cite[pág. 196, tradução nossa]{Martin2018}}

  Muitos autores, ao longo de seus anos de experiência com desenvolvimento de software, estabeleceram suas próprias noções de arquitetura de sistemas, e apesar de terem nomes distintos - \emph{BCE}\cite{Jacobson1992}, \emph{Hexagonal}\cite{Cockburn2005}, \emph{Onion}\cite{Palermo2008}, \emph{DCI}\cite{Coplien2010} - elas compartilham características que as enquadram no conceito de \emph{Arquitetura Limpa}\cite{Martin2018}, notoriamente: \emph{Independente de frameworks}, \emph{Testável}, \emph{Independente de interface de usuário}, \emph{Independente de banco de dados} e {Independente de qualquer agente externo}.

  Elas também guardam a chamada \emph{Regra da Dependência}, onde, segundo \citeonline[p. 197, tradução nossa]{Martin2018} "as dependências do código fonte deve apontar somente na direção do centro do círculo, rumo as políticas de alto nível", como pode ser observado na \figref{clean-architecture}.

  \imagem
    {scale=0.4}
    {Modelo de Arquitetura Limpa}
    {CleanArchitecture.jpg}
    {clean-architecture}
    {\cite[pág. 197]{Martin2018}}

  \subsection{Como o desenvolvimento guiado por testes auxilia na obtenção de uma arquitetura limpa?}

    É fácil encontrar muitas similaridades entre a arquitetura convencional e a de software, mas existe um quesito que pesa a favor da última: como o nome sugere, soft (em português: flexível, suave) é um bem intangível, cuja construção, guardadas as devidas proporções e contextos, não oferece os mesmos riscos, por vezes irreparáveis, que a primeira está sujeita.

    Desenvolvimento guiado por testes privilegia uma conduta que permite definir as funções essenciais do sistema, implementá-las da maneira mais simplória conhecida e através de sucessivas modificações, amparadas por uma rede de proteção que previne regressões, alcançar um modelo que expressa, claramente, quais seus objetivos e permite uma evolução sustentável do produto.

\section{O estudo de caso}
\section{Trabalhos relacionados}

  \subsection{O jogo}

    Hive\footnotemark é um jogo abstrato de duelo, tal qual o xadrez, onde os jogadores devem usar seus respectivos acervos para cercar o alvo oponente.
    \footnotetext{Tradução e adaptação nossa do sítio "UltraBoardGames: How to Play Hive". Disponível em: \url{https://www.ultraboardgames.com/hive/game-rules.php}. Acesso em: 29 de janeiro de 2021.}

    Cada jogador possui onze peças em formato hexagonal de cinco tipos distintos, cada tipo sendo representado por um inseto: uma abelha rainha, o alvo; duas aranhas; dois besouros; três gafanhotos; e, três formigas.

    Apenas uma ação, das duas possíveis, é permitida aos jogadores executar por turno: entrada e movimentação.

    Quando entra em jogo, uma peça deve ser colocada adjacente a uma que já está, à exceção daquela colocada no primiero turno do jogo. Ela também não deve tocar nenhuma peça adversária, reservada aquela que o faz no segundo turno, posto que a regra anterior deve ser atendida.

    A abelha rainha deve entrar, no máximo, até a quarta rodada. Enquanto isso não ocorrer, nenhuma peça irmã poderá ser movimentada.

    Os insetos tem movimentações diversas. A abelha rainha, um passo por vez ao redor da colméia. As aranhas, três passos ao redor da colméia, sempre na mesma direção iniciada. Os besouros, um passo ao redor da colméia ou acima dela, e a peça sob o qual ele pousa fica imobilizada até que ele a deixe e, para efeito de novas entradas, a posição ocupada assume a cor do mesmo. Os gafanhotos, se movimentam sobre a colméia, iniciando de um lado e seguindo em linha reta (perpendicular a aresta escolhida) até o lado oposto. E,  as formigas, o fazem ao redor da colméia sem limites de passos. Tais ações não podem resultar em uma colméia fragmentada, mesmo que o resultado seja uma colméia intacta. As movimentações ao redor devem ser de livre deslize, não sendo permitido entrar em uma posição onde isso não é possível.

    Finalmente, a abelha rainha é considerada cercada quando todos os seus lados estão ocupados por alguma peça em jogo, independente de a quem elas pertençam.

  \subsection{O escopo}

    O objetivo é construir uma aplicação onde um usuário qualquer possa se registrar para adquirir acesso. Uma vez autenticado ele pode propor ou responder a uma proposta de partida com um adversário que tenha realizado o mesmo caminho. E, obviamente, desempenhar uma partida. Deve, ainda, ser possível, organizar torneios, visualizar uma lista de classificação dos jogadores por suas respectivas pontuações e, apenas, observar uma partida, sem dela participar. É desejável que o registro e a autenticação possam ser realizados utilizando os mecanismos ofertados pelo Google e Facebook, bem como retomar uma partida que foi explicita ou implicitamente suspensa (um dos jogadores pode ter perdido a conexão por problemas em sua rede). Os jogadores devem ser capazes de convidar um adversário específico para uma partida. Também seria interessante que os usuários possam recuperar suas senhas que, ocasionalmente, possam vir a esquecer ou alterar informações sobre si (como nome que é apresentado aos demais, imagem de perfil, etc) além, é claro, de poder remover sua conta, caso não tenha mais interesse no serviço.

    Essa é uma descrição hipotética de necessidade inicial de um interessado em patrocinar um projeto dessa qualidade. Claro, em uma situação real, muitos outros detalhes deveriam ser capturados para refinar a solução, mas aqui vamos partir da premissa que esta é nossa única demanda.

  \input{nova-solucao}
